HW #1

Due April 1, 2016 at 11:59pm

 

This homework is to be completed individually. You can discuss the assignment with other students in thinking about how to solve these problems, but all programming and other portions of the assignment must be entirely your own work. You may not show your code to other students. Undergraduates may work in teams with up to one other student, while graduate students must work individually. If you are working with another student, you need to designate this by forming a group in Canvas.

 

This assignment should be implemented in C++ and turned in using Canvas.

 

Task:

 

In this assignment you will implement two environments (domains) and two algorithms that are able to run on these environments. An environment is a class that provides methods for getting legal moves, applying moves and undoing moves. An algorithm should be a C++ template class that performs a search using the environment provided as a template parameter, and start/goal states provided as arguments.

 

Problem domains (Environments):

1) Grid-based movement on an empty map

Implement a square grid domain where an agent can move to any of the two adjacent locations (up/right) that is not outside of the grid. The size of the grid should be passed in as a parameter, and legal coordinates should begin at (0, 0) and continue up until the maximum coordinate passed in as a parameter. For this assignment assume there are no obstacles in the grid. This state space can be implemented implicitly. Use (0,0) as the start state.

2) N-ary trees

N-ary trees are the abstract model of an exponential domain. Implement a tree where the branching factor (b) and the depth of the tree (d) can be varied programmatically. This is an implicit state space, so a state in the tree is just an index.

Algorithms:

1) Depth-First Iterative Deepening

Implement the DFID algorithm. This algorithm should include a depth-limited depth-first search which is called repeatedly with larger depth bounds until the goal is found. The algorithm does not need to return the path found, but should report the total number of nodes expanded. (For debugging purposes you may want to print the number of nodes expanded in each depth-limited iteration.)

2) Breadth-First Search

Implement a simple breadth-first search. This algorithm should assume (albeit incorrectly) that none of the input domains contain any cycles. The search should terminate when the goal is found, but does not need to return the path that was found. After the goal is found, it should report the total number of nodes expanded.

Testing:

Both algorithms should be bested on both domains. Validate, when possible, that they are expanding the correct number of nodes. Vary the difficulty of the grid-based movement problem to see how large of a problem you can solve in reasonable amounts of time.

What to turn in: 

Your submission should include the code for the two domains, the two algorithms, and a sample program which tests the domains and algorithms together. Along with the code also submit a sample run of your testing program. Graduate students should also include a formal writeup that provides the experimental results in tables and explains the algorithms, domains, as well as the final results. A sample write-up will be posted shortly.

 

Sample Code:

 

In C++ using templates an environment might look like the code below. 

class MyEnvironment {
public:
 void GetActions(MyState &nodeID, std::vector<MyAction> &actions);
 void ApplyAction(MyState &s, MyAction a);
 void UndoAction(MyState &s, MyAction a);
};
Note that we do not necessarily want to use inheritance here because each environment may have a significantly different state and action definition. Thus, templates are more appropriate, because we can use in the appropriate state/action definition with each environment.

Given this, an algorithm will look something like this:

template <typename state, typename action, typename environment>
class MySearchAlgorithm
{
public:
 MySearchAlgorithm();
 // GetPath returns if the goal was found
 bool GetPath(environment &e, state &start, state &goal);
 // Returns the total nodes expanded by the last GetPath call.
 uint64_t GetNodesExpanded();
private:
     // ...
};
 

Note that this code can be written to work on any environment, as long as GetActions, ApplyAction, and UndoAction are written consistently for the template types. This doesn't require inheritance.